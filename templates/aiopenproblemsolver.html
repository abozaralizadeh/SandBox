<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="license" content="MIT License">
    <meta name="author" content="Abozar Alizadeh">
    <title>AI Open Problem Solver</title>
    <link rel="icon" type="image/png" href="/static/faviconAB.png">
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "to3v9nfkh6");
    </script>
    <style>
        :root {
            color-scheme: light dark;
            --bg: #0b1120;
            --fg: #f9fafb;
            --accent: #38bdf8;
            --card-bg: rgba(15, 23, 42, 0.75);
            --border: rgba(148, 163, 184, 0.35);
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html {
            width: 100%;
            overflow-x: hidden;
        }

        body {
            margin: 0;
            font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: radial-gradient(circle at top, rgba(56, 189, 248, 0.25), transparent 45%), var(--bg);
            color: var(--fg);
            min-height: 100vh;
            overflow-x: hidden;
        }

        a {
            color: var(--accent);
        }

.topbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 20;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.6rem;
    padding: calc(0.6rem + env(safe-area-inset-top, 0px)) clamp(1rem, 4vw, 3rem) 0.6rem clamp(1rem, 4vw, 3rem);
            background: rgba(11, 17, 32, 0.92);
            border-bottom: 1px solid rgba(148, 163, 184, 0.35);
            box-shadow: 0 12px 30px rgba(8, 15, 28, 0.35);
            transform: translateY(-110%);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.35s ease, opacity 0.35s ease;
        }

        .topbar.visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .topbar-left {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            min-width: 0;
            flex: 1 1 240px;
        }

        .topbar-home {
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            color: var(--accent);
            white-space: nowrap;
        }

        .topbar-title {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            line-height: 1.2;
            color: var(--fg);
            white-space: normal;
            overflow-wrap: anywhere;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            min-width: 0;
            flex: 1 1 320px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .topbar-select {
            flex: 1 1 240px;
            min-width: 0;
            padding: 0.45rem 0.75rem;
            border-radius: 0.6rem;
            border: 1px solid var(--border);
            background: rgba(10, 31, 53, 0.85);
            color: var(--fg);
            font-size: 0.9rem;
            white-space: normal;
            line-height: 1.4;
        }

        .topbar-button {
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 0.6rem;
            border: none;
            font-weight: 600;
            font-size: 0.85rem;
            background: var(--accent);
            color: #0f172a;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .topbar-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(56, 189, 248, 0.35);
        }

        .page-header {
            position: sticky;
            top: 0;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.85);
            border-bottom: 1px solid var(--border);
            padding: 1.5rem clamp(1rem, 4vw, 3rem);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .page-header .title-bar {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 1rem;
            justify-content: space-between;
        }

        .page-header h1 {
            margin: 0;
            font-size: clamp(1.8rem, 3vw, 2.4rem);
            letter-spacing: 0.04em;
        }

        .page-header form {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .input-group {
            flex: 1 1 320px;
            display: flex;
            gap: 0.5rem;
            min-width: 0;
        }

        select {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            background: rgba(15, 23, 42, 0.65);
            color: var(--fg);
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            min-width: 0;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
            white-space: normal;
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            font-weight: 600;
            font-size: 1rem;
            background: var(--accent);
            color: #0f172a;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(56, 189, 248, 0.35);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        main {
            padding: 2rem clamp(1rem, 4vw, 3rem) 4rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-x: hidden;
        }

        .loader-wrapper {
            display: none;
            justify-content: center;
            padding: 1rem 0;
        }

        .loader-wrapper.visible {
            display: flex;
        }

        .loader {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 4px solid rgba(148, 163, 184, 0.25);
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
        }

        .status {
            font-size: 0.95rem;
            opacity: 0.85;
        }

        .entries {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .entry {
            border: 1px solid var(--border);
            border-radius: 1.25rem;
            padding: clamp(1.5rem, 3vw, 2.25rem);
            background: var(--card-bg);
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.35);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            max-width: 100%;
        }

        .entry header {
            position: static;
            background: transparent;
            border: 0;
            padding: 0;
            gap: 0.4rem;
        }

        .entry h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .entry time {
            font-size: 0.95rem;
            opacity: 0.75;
        }

        .html-content {
            border-radius: 0.75rem;
            background: rgba(15, 23, 42, 0.55);
            padding: 1.5rem;
            line-height: 1.6;
            overflow-x: auto;
            overflow-wrap: anywhere;
        }

        .html-content h1,
        .html-content h2,
        .html-content h3 {
            color: var(--accent);
        }

        .metadata {
            display: grid;
            gap: 1.25rem;
            overflow-wrap: anywhere;
        }

        .metadata section {
            border-top: 1px solid var(--border);
            padding-top: 1rem;
        }

        .metadata h3 {
            margin: 0 0 0.5rem;
            font-size: 1.1rem;
            letter-spacing: 0.02em;
        }

        ul {
            padding-left: 1.25rem;
            margin-inline: 0;
            overflow-wrap: anywhere;
        }

        .end-message {
            text-align: center;
            opacity: 0.7;
            font-size: 0.9rem;
            margin-top: 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

@media (max-width: 640px) {
    .topbar {
        padding: calc(0.45rem + env(safe-area-inset-top, 0px)) 0.75rem 0.45rem 0.75rem;
        gap: 0.5rem;
        justify-content: center;
    }
            .topbar-left,
            .topbar-right {
                flex: 1 1 100%;
                justify-content: center;
            }
            .topbar-right {
                flex-direction: row;
                align-items: center;
            }
            .topbar-select {
                flex: 1 1 75%;
                width: 100%;
            }
            .topbar-button {
                width: 34px;
                height: 34px;
                flex: 0 0 34px;
            }
            .topbar-title {
                font-size: 0.95rem;
                text-align: center;
            }
            .topbar-home {
                font-size: 0.85rem;
            }
        }
    </style>
</head>

<body>
    <div class="topbar" id="floatingToolbar">
        <div class="topbar-left">
            <a class="topbar-home" href="/">← Home</a>
            <h2 class="topbar-title">AI Open Problem Solver</h2>
        </div>
        <div class="topbar-right">
            <select id="topbarProblemSelect" class="topbar-select" disabled>
                <option>Loading…</option>
            </select>
            <button type="button" id="scrollTopBtn" class="topbar-button" title="Back to top">↑</button>
        </div>
    </div>
    <header class="page-header">
        <div class="title-bar">
            <h1>AI Open Problem Solver</h1>
            <a class="home-link" href="/" style="color: var(--accent); text-decoration: none;">← Back to Home</a>
        </div>
        <form id="problemForm">
            <div class="input-group">
                <label for="problemSelect" class="sr-only">Open Problem</label>
                <select id="problemSelect" name="problem" disabled>
                    <option value="">Loading problems…</option>
                </select>
            </div>
            <button type="submit" id="updateProblem" disabled>Load Progress</button>
        </form>
        <div class="status" id="statusLine">Loading problems…</div>
        <p id="problemDescription" style="margin: 0; opacity: 0.85; overflow-wrap: anywhere;">{{ default_problem_description }}</p>
        {% set initial_progress_text = "" %}
        {% if default_problem_progress_percent is not none %}
            {% set rounded = (default_problem_progress_percent * 10)|round|int / 10 %}
            {% set initial_progress_text = "Progress: " ~ ("%0.1f"|format(rounded)).rstrip('0').rstrip('.') ~ "%" %}
            {% if default_problem_progress_comment %}
                {% set initial_progress_text = initial_progress_text ~ " — " ~ default_problem_progress_comment %}
            {% endif %}
        {% elif default_problem_progress_comment %}
            {% set initial_progress_text = default_problem_progress_comment %}
        {% endif %}
        <p id="problemProgress" style="margin: 0; opacity: 0.85; overflow-wrap: anywhere;">{{ initial_progress_text }}</p>
    </header>
    <main>
        <div id="loaderWrapper" class="loader-wrapper">
            <div class="loader"></div>
        </div>
        <div class="entries" id="entries"></div>
        <div class="end-message" id="endMessage" hidden>No more recorded progress. Check back tomorrow!</div>
    </main>

    <footer style="padding: 2rem clamp(1rem,4vw,3rem); text-align: center; font-size: 0.9rem; opacity: 0.75;">
        © {{ (now().year if now else 2025) }} <a href="https://github.com/abozaralizadeh/SandBox" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">SandBox Project</a>. Open source and community-driven.
    </footer>

    <script>
        const defaultProblem = {{ default_problem|tojson }};
        const defaultProblemDescription = {{ default_problem_description|tojson }};
        const defaultProblemProgressPercent = {{ default_problem_progress_percent|tojson }};
        const defaultProblemProgressComment = {{ default_problem_progress_comment|tojson }};

        const entriesContainer = document.getElementById("entries");
        const loaderWrapper = document.getElementById("loaderWrapper");
        const endMessage = document.getElementById("endMessage");
        const statusLine = document.getElementById("statusLine");
        const problemForm = document.getElementById("problemForm");
        const topbar = document.getElementById("floatingToolbar");
        const scrollTopBtn = document.getElementById("scrollTopBtn");
        const problemSelect = document.getElementById("problemSelect");
        const topbarSelect = document.getElementById("topbarProblemSelect");
        const updateButton = document.getElementById("updateProblem");
        const problemDescription = document.getElementById("problemDescription");
        const problemProgress = document.getElementById("problemProgress");

        const primarySelects = [problemSelect, topbarSelect];
        const loadButtons = [updateButton];
        const problemsCache = new Map();

        let currentProblem = defaultProblem || "";
        let offset = 0;
        let loading = false;
        let hasMore = true;
        let firstLoad = true;

        function updateStatus(text) {
            statusLine.textContent = text;
        }

        function toggleLoader(show) {
            if (show) {
                loaderWrapper.classList.add("visible");
            } else {
                loaderWrapper.classList.remove("visible");
            }
        }

        function createList(items) {
            if (!items || !items.length) {
                return "<p>No data available.</p>";
            }
            return `<ul>${items.map(item => `<li>${item}</li>`).join("")}</ul>`;
        }

        function formatEntry(entry) {
            const createdAt = entry.created_at || entry.timestamp || entry.rowKey;
            const dateObj = createdAt ? new Date(createdAt) : null;
            const date = dateObj ? dateObj.toLocaleDateString() : "Unknown date";
            const metadata = entry.metadata || {};
            const nextStepsMarkup = createList(metadata.next_steps || []);
            const referencesMarkup = createList(metadata.references || []);

            const wrapper = document.createElement("article");
            wrapper.className = "entry";
            wrapper.innerHTML = `
                <header>
                    <h2>Update • ${date}</h2>
                    <time>${entry.summary || "No summary provided."}</time>
                </header>
                <section class="html-content">${entry.html_content || "<p>No HTML content returned.</p>"}</section>
                <section class="metadata">
                    <section>
                        <h3>Next Steps</h3>
                        ${nextStepsMarkup}
                    </section>
                    <section>
                        <h3>References</h3>
                        ${referencesMarkup}
                    </section>
                </section>
            `;
            entriesContainer.appendChild(wrapper);
        }

        function syncSelectors(value) {
            primarySelects.forEach(select => {
                select.value = value;
                select.disabled = !value;
            });
            loadButtons.forEach(btn => (btn.disabled = !value));
        }

        async function loadProblemOptions() {
            try {
                const response = await fetch('/ai-open-problem-solver/problems');
                if (!response.ok) throw new Error(`Server error (${response.status})`);
                const payload = await response.json();
                const problems = payload.problems || [];

                problemsCache.clear();
                if (defaultProblem) {
                    problemsCache.set(defaultProblem, {
                        name: defaultProblem,
                        description: defaultProblemDescription || "",
                        progressPercent: typeof defaultProblemProgressPercent === "number" ? defaultProblemProgressPercent : null,
                        progressComment: (defaultProblemProgressComment || "").trim(),
                    });
                }

                problems.forEach(entry => {
                    const name = (entry && (entry.name || entry.problem)) ? String(entry.name || entry.problem).trim() : "";
                    if (!name) return;
                    const description = entry && entry.description ? String(entry.description) : "";
                    const existing = problemsCache.get(name);
                    if (!existing) {
                        problemsCache.set(name, {
                            name,
                            description,
                            progressPercent: null,
                            progressComment: "",
                        });
                    } else if (!existing.description && description) {
                        existing.description = description;
                        problemsCache.set(name, existing);
                    }
                });

                primarySelects.forEach(select => {
                    select.innerHTML = "";
                    select.disabled = true;
                });

                if (problemsCache.size === 0) {
                    const fallback = '<option value="">No problems found</option>';
                    primarySelects.forEach(select => (select.innerHTML = fallback));
                    syncSelectors("");
                    updateStatus("No stored problems available. Add entries via storage to begin.");
                    currentProblem = "";
                    problemDescription.textContent = "";
                    problemProgress.textContent = "";
                    return;
                }

                const sortedProblems = Array.from(problemsCache.values()).sort((a, b) =>
                    a.name.localeCompare(b.name)
                );

                sortedProblems.forEach(({ name }) => {
                    const option = document.createElement("option");
                    option.value = name;
                    option.textContent = name;
                    problemSelect.appendChild(option.cloneNode(true));
                    topbarSelect.appendChild(option);
                });

                if (!currentProblem || !problemsCache.has(currentProblem)) {
                    currentProblem = sortedProblems[0].name;
                }
                syncSelectors(currentProblem);
                updateStatus(`Loaded ${sortedProblems.length} problem${sortedProblems.length === 1 ? "" : "s"}.`);
                updateProblemDescription(currentProblem);
            } catch (error) {
                console.error(error);
                const fallback = '<option value="">Unable to load problems</option>';
                primarySelects.forEach(select => (select.innerHTML = fallback));
                syncSelectors("");
                updateStatus(`Failed to load problems: ${error.message}`);
                currentProblem = "";
                problemDescription.textContent = "";
                problemProgress.textContent = "";
            }
        }

        async function loadMoreEntries({ reset = false, showSpinner = false } = {}) {
            if (loading && !reset) return;

            if (reset) {
                offset = 0;
                hasMore = true;
                endMessage.hidden = true;
                firstLoad = true;
            }

            loading = true;
            if (showSpinner) toggleLoader(true);
            updateStatus("Researching… this can take several minutes for deep web exploration.");

            const params = new URLSearchParams({
                problem: currentProblem,
                offset: offset.toString(),
                limit: "3",
            });

            if (firstLoad) params.set("ensure_latest", "true");

            try {
                const response = await fetch(`/ai-open-problem-solver/history?${params.toString()}`);
                if (!response.ok) throw new Error(`Server error (${response.status})`);
                const payload = await response.json();

                const entries = payload.entries || [];
                if (reset) entriesContainer.innerHTML = "";

                if (entries.length === 0 && offset === 0) {
                    updateStatus("No recorded progress yet. Triggering a fresh research iteration.");
                }

                entries.forEach(formatEntry);

                if (payload.next_offset === null || typeof payload.next_offset === "undefined") {
                    hasMore = false;
                    endMessage.hidden = entries.length === 0;
                } else {
                    offset = payload.next_offset;
                }

                if (entries.length > 0) {
                    if (reset) {
                        const latest = entries[0];
                        const percent = typeof latest.progress_percent === "number" ? latest.progress_percent : null;
                        const comment = (latest.progress_comment || "").trim();
                        if (problemsCache.has(currentProblem)) {
                            const cached = problemsCache.get(currentProblem);
                            cached.progressPercent = percent;
                            cached.progressComment = comment;
                            problemsCache.set(currentProblem, cached);
                        }
                        renderProgress(percent, comment, true);
                    }
                    updateStatus(`Showing ${entriesContainer.children.length} updates for "${currentProblem}".`);
                } else if (!hasMore) {
                    updateStatus(`No results stored for "${currentProblem}" yet. Re-run later.`);
                }
            } catch (error) {
                console.error(error);
                updateStatus(`Failed to load progress: ${error.message}`);
            } finally {
                toggleLoader(false);
                loading = false;
                firstLoad = false;
            }
        }

        function handleLoadRequest(select) {
            const nextProblem = select.value.trim();
            if (!nextProblem) {
                updateStatus("Please describe the open problem you want to tackle.");
                return;
            }
            if (nextProblem !== currentProblem) {
                currentProblem = nextProblem;
                updateProblemDescription(currentProblem);
                loadMoreEntries({ reset: true, showSpinner: true });
            } else {
                loadMoreEntries({ reset: true, showSpinner: true });
            }
            syncSelectors(nextProblem);
        }

        problemForm.addEventListener("submit", (event) => {
            event.preventDefault();
            handleLoadRequest(problemSelect);
        });
        primarySelects.forEach(select => select.addEventListener("change", () => handleLoadRequest(select)));

        window.addEventListener("scroll", () => {
            if (loading || !hasMore) return;
            const scrollPosition = window.scrollY + window.innerHeight;
            const threshold = document.body.offsetHeight - 600;
            if (scrollPosition >= threshold) {
                loadMoreEntries({ reset: false, showSpinner: false });
            }
        });

        loadProblemOptions().then(() => {
            if (currentProblem) {
                if (!problemDescription.textContent && defaultProblemDescription) {
                    problemDescription.textContent = defaultProblemDescription;
                }
                renderProgress(
                    typeof defaultProblemProgressPercent === "number" ? defaultProblemProgressPercent : null,
                    (defaultProblemProgressComment || "").trim(),
                    true
                );
                loadMoreEntries({ reset: true, showSpinner: false });
            } else if (!problemSelect.disabled) {
                updateStatus("Select a problem to get started.");
            }
        });

        function updateProblemDescription(problem) {
            if (!problem) {
                problemDescription.textContent = "";
                renderProgress(null, "", true);
                return;
            }
            const cached = problemsCache.get(problem);
            if (cached && cached.description) {
                problemDescription.textContent = cached.description;
            } else {
                problemDescription.textContent = "";
            }

            const cachedHasProgress =
                cached &&
                ((typeof cached.progressPercent === "number" && !Number.isNaN(cached.progressPercent)) ||
                    (cached.progressComment && cached.progressComment.length));
            renderProgress(
                cachedHasProgress ? cached.progressPercent : null,
                cachedHasProgress ? cached.progressComment : "",
                true
            );

            fetch(`/ai-open-problem-solver/problem-details?problem=${encodeURIComponent(problem)}`)
                .then(response => response.json())
                .then(data => {
                    const description = ((data && data.description) || "").trim();
                    if (description) {
                        problemDescription.textContent = description;
                    }
                    const percent = typeof data.progress_percent === "number" ? data.progress_percent : null;
                    const comment = ((data && data.progress_comment) || "").trim();
                    renderProgress(percent, comment);
                    if (cached) {
                        if (description) cached.description = description;
                        cached.progressPercent = percent;
                        cached.progressComment = comment;
                        problemsCache.set(problem, cached);
                    } else if (description || comment || percent !== null) {
                        problemsCache.set(problem, {
                            name: problem,
                            description,
                            progressPercent: percent,
                            progressComment: comment,
                        });
                    }
                })
                .catch(() => {
                    // Keep existing description/progress if details fetch fails.
                });
        }

        function renderProgress(percent, comment, force = false) {
            const hasValue =
                (typeof percent === "number" && !Number.isNaN(percent)) ||
                (comment && comment.length);
            if (!hasValue && !force) {
                return;
            }
            let text = "";
            if (typeof percent === "number" && !Number.isNaN(percent)) {
                const rounded = Math.round(percent * 10) / 10;
                text = `Progress: ${rounded}%`;
                if (comment) {
                    text += ` — ${comment}`;
                }
            } else if (comment) {
                text = comment;
            } else {
                text = "";
            }
            problemProgress.textContent = text;
        }

        const headerSection = document.querySelector(".page-header");
        let toolbarVisible = false;
        const observer = new IntersectionObserver(
            ([entry]) => {
                const ratio = entry.intersectionRatio;
                const headerMostlyHidden = ratio <= 0.05 && entry.boundingClientRect.top < -20;
                const headerMostlyVisible = ratio >= 0.6;

                if (!toolbarVisible && headerMostlyHidden) {
                    toolbarVisible = true;
                    topbar.classList.add("visible");
                } else if (toolbarVisible && headerMostlyVisible) {
                    toolbarVisible = false;
                    topbar.classList.remove("visible");
                }
            },
            { threshold: [0, 0.05, 0.6, 1] }
        );
        observer.observe(headerSection);

        scrollTopBtn.addEventListener("click", () => {
            window.scrollTo({ top: 0, behavior: "smooth" });
        });
    </script>
</body>

</html>
